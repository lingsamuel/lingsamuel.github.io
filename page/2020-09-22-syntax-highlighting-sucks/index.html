<!DOCTYPE html><html lang="zh" itemscope="" itemtype="http://schema.org/WebPage"><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><title>Syntax Highlighting Sucks - Hakurei Shrine</title><link rel="alternate" href="https://lingsamuel.github.io/index.xml" type="application/rss+xml" title="Hakurei Shrine"><link href="https://lingsamuel.github.io/img/favicon.ico" rel="icon" type="image/x-icon" alt="favicon"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&amp;family=Source+Serif+Pro:wght@400;700&amp;display=swap" rel="stylesheet"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&amp;family=Noto+Sans+SC:wght@100;300;400;500;700;900&amp;family=Noto+Serif+SC:wght@200;300;500;600;900&amp;family=Source+Serif+Pro:ital,wght@0,200;0,300;0,600;0,900;1,200;1,300;1,400;1,600;1,700;1,900&amp;display=swap" media="screen" as="style" onload="this.rel='stylesheet'"><link rel="stylesheet" href="https://lingsamuel.github.io/css/main.min.css" media="screen"><link rel="stylesheet" href="https://lingsamuel.github.io/css/book.min.css" media="screen" as="style" onload="this.rel='stylesheet'"><link rel="stylesheet" href="https://lingsamuel.github.io/css/quotes.min.css" media="screen" as="style" onload="this.rel='stylesheet'"><script type="application/javascript">var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-89095899-1','auto'),ga('send','pageview'))</script><script async="" src="https://www.google-analytics.com/analytics.js"></script></head><body id="body"><nav id="navbar"><div class="nav"><div class="navbar-header"><img src="https://lingsamuel.github.io/img/favicon.ico" class="favicon" alt="favicon"><a href="https://lingsamuel.github.io/">
Hakurei Shrine</a></div><div class="navbar-menu"><ul><li><a title="Articles" href="/page">Articles</a></li><li><a title="Reviews" href="/review">Reviews</a></li><li><a title="Feeds" href="/feed">Feeds</a></li><li><a title="Kubernetes" href="/k8s">Kubernetes</a></li><li><a title="About" href="/about">About</a></li><li><a title="Categories" href="/categories">Categories</a></li><li><a title="Tags" href="/tags">Tags</a></li></ul></div></div></nav><div class="flex-container"><div class="container container-single" id="mainContainer" role="main"><header class="header post-header"><div class="row"><div class="post-title"><h1>Syntax Highlighting Sucks</h1><hr class="small"><h2 class="post-subtitle">but static analysis rocks</h2></div><div class="post-meta"><span class="author">Ling Samuel</span>
•
<span class="date">2020-09-22</span>
•
<span class="categories"><a href="https://lingsamuel.github.io/categories/thought/">thought</a>&nbsp;
<a href="https://lingsamuel.github.io/categories/programming/">programming</a>&nbsp;</span></div></div></header><div class="row"><div><article role="main" class="post-content"><p>不得不承认，即使是在最现代的 IDE 工具集（JetBrains 系列）中，语法高亮的配置如此之多，依旧无法解决代码编写与阅读中的核心问题——语义理解。</p><p>当然，JetBrains IDEs 在其他方面依旧做的足够出色。</p><h2 id="当我们在谈论语法高亮时我们在谈论什么">当我们在谈论语法高亮时，我们在谈论什么</h2><p>实际上，无论是语法高亮，还是 linter、静态分析等更高级的程序分析工具，最终的目标都是辅助程序员阅读、编写代码。</p><p>然而，（我的）实践表明，即使是精心配置过的语法高亮，在辅助代码阅读上的功能，甚至完全不如更加简单的类型标注来得有效（当然我还是不能理解为什么 JetBrains 的 IDE 明明会自动插入类型 Label，却不能点击这个 Label 来跳转到类型定义）。</p><p>在初学编程时，我也特别喜欢配置繁复的语法高亮规则，让代码看起来五颜六色，似乎这能帮助我阅读代码。</p><p>但以我现在的眼光来看，这是完完全全错误的做法。五颜六色的代码只会加重大脑的负担。</p><p>总体上来看，语法高亮真正有效的作用有：</p><ul><li>辅助人们忽略一切不关键的部分。也许只有这部分，可以称作是 <code>syntax highlight</code>。</li><li>辅助显示静态分析的结果。这部分更多的并不是 <code>syntax</code>，而是 <code>static analysis</code>。<ul><li>突出显示一些特定的语法元素。例如，使用一种特别的颜色或字体来显示全局变量。</li></ul></li></ul><h3 id="忽略不关键的部分">忽略不关键的部分</h3><p><span style="font-family: &quot;Chinese Quote Serif&quot;, &quot;source serif pro&quot;, &quot;noto serif sc&quot;, &quot;source serif&quot;, &quot;source han serif sc&quot;, &quot;source han serif cn&quot;, serif;">什么是不关键的部分？实际上，几乎所有的“关键字”都是不关键的。绝大部分时候，没有人在乎一个循环到底是</span> for 还是 while，没有人在乎这个 switch 到底有几个 case，没有人在乎一个函数究竟有几个修饰符。</p><p>我们关心的是 for/while 循环的是谁，是 switch/case 的条件，是函数的实现。在这一点上，语法高亮确实很好地完成了它的工作——用统一的颜色标注出关键字，好告诉程序员们这部分完全可以忽略。</p><h3 id="无意义的高亮">无意义的高亮</h3><p>但语法高亮有时候加重了代码阅读的负担。</p><p><span style="font-family: &quot;Chinese Quote Serif&quot;, &quot;source serif pro&quot;, &quot;noto serif sc&quot;, &quot;source serif&quot;, &quot;source han serif sc&quot;, &quot;source han serif cn&quot;, serif;">到底是谁发明的“函数”需要有颜色？是的，我确实有时候需要区分一个函数到底是</span> accessor, extension method, static method, overloaded method, operator<span style="font-family: &quot;Chinese Quote Serif&quot;, &quot;source serif pro&quot;, &quot;noto serif sc&quot;, &quot;source serif&quot;, &quot;source han serif sc&quot;, &quot;source han serif cn&quot;, serif;">，等等等等。天杀的，一个“函数调用”怎么会有那么多种类型！</span></p><p>——但这一切仅仅发生在阅读代码的人不熟悉 codebase，且需要更改它的时候。</p><p>一个对代码库了如指掌的人，或者是一个根本不想修改代码库，只是想看看代码如何工作的人，根本不会关注一个函数到底是什么类型。</p><p>应该关心的是什么？是语义！</p><p>在一长串的函数调用中，我们真正关心的是这个函数<em>做了什么</em>，而非<em>是什么</em>。实际上，我根本无法从一堆函数调用的颜色上获取任何信息。一个函数是什么种类，和它的语义有任何关系吗？没有。</p><p>一个最最简单的例子，我实在迫切需要一个高亮元素，帮助我知道一个函数是 mutable 还是 immutable 的（哪怕这个语言本身并没有类似的支持），如果是 mutable 的，他 mutate 了的是哪个参数。</p><p>更进一步，我还想一眼看过去就能发觉，哪些函数是在准备数据，处理异常，哪些函数才是真正的核心逻辑。我根本不关心各种各样的输入输出是怎么被处理成内部数据结构的。</p><p>我还关心不同分支中哪一部分的代码具有相同的特征、完成类似的工作。</p><p>以我最近阅读的一段 <a href="https://github.com/projectcalico/node">calico-node</a> 的代码为例（<a href="https://github.com/projectcalico/node/blob/cceb0a1a42e580e2e1622a922334886fc3eaf7cc/pkg/startup/startup.go#L700-L743">完整代码段</a>）：</p><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">autoDetectCIDR</span><span class="p">(</span><span class="nx">method</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">version</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">cnet</span><span class="p">.</span><span class="nx">IPNet</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="s">""</span> <span class="o">||</span> <span class="nx">method</span> <span class="o">==</span> <span class="nx">AUTODETECTION_METHOD_FIRST</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">autoDetectCIDRFirstFound</span><span class="p">(</span><span class="nx">version</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">AUTODETECTION_METHOD_INTERFACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// ...
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">autoDetectCIDRByInterface</span><span class="p">(</span><span class="nx">ifRegexes</span><span class="p">,</span> <span class="nx">version</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">AUTODETECTION_METHOD_CIDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// ...
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">autoDetectCIDRByCIDR</span><span class="p">(</span><span class="nx">matches</span><span class="p">,</span> <span class="nx">version</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">AUTODETECTION_METHOD_CAN_REACH</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// ...
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">autoDetectCIDRByReach</span><span class="p">(</span><span class="nx">destStr</span><span class="p">,</span> <span class="nx">version</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">AUTODETECTION_METHOD_SKIP_INTERFACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// ...
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">autoDetectCIDRBySkipInterface</span><span class="p">(</span><span class="nx">ifRegexes</span><span class="p">,</span> <span class="nx">version</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// The autodetection method is not recognised and is required.  Exit.
</span><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">"Invalid IP autodetection method: %s"</span><span class="p">,</span> <span class="nx">method</span><span class="p">)</span>
	<span class="nf">terminate</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这一段代码算的上是非常经典的分支结构。实际上原本的代码也并不是特别复杂，但我相信大家一定都见过更复杂的类似版本，它们甚至可能在 if 里套 if。实际上大多数时候形如此的代码阅读体验都甚是糟糕。IDE 没有提供任何有关<strong>核心</strong>代码与数据流向的提示，但幸而我展示的这段代码逻辑并不复杂，每个分支的核心逻辑仅仅只有一个 return 而已。更多时候我们不得不非常仔细地阅读每一个 if，找到我们关心的那一个，然后在脑内仔细模拟代码运行，最终找到我们想要的部分。</p><p>此外，我也非常关心函数的返回值在哪里被生成，在哪里被修改了。</p><p>还是以 <a href="https://github.com/projectcalico/node/blob/cceb0a1a42e580e2e1622a922334886fc3eaf7cc/pkg/startup/startup.go#L840-L853">calico-node</a> 的代码为例。</p><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// generateIPv6ULAPrefix return a random generated ULA IPv6 prefix as per RFC 4193.  The pool
</span><span class="c1">// is generated from bytes pulled from a secure random source.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GenerateIPv6ULAPrefix</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ulaAddr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mh">0xfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cryptorand</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">ulaAddr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">ipNet</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">IPNet</span><span class="p">{</span>
		<span class="nx">IP</span><span class="p">:</span>   <span class="nx">net</span><span class="p">.</span><span class="nf">IP</span><span class="p">(</span><span class="nx">ulaAddr</span><span class="p">),</span>
		<span class="nx">Mask</span><span class="p">:</span> <span class="nx">net</span><span class="p">.</span><span class="nf">CIDRMask</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ipNet</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p><span style="font-family: &quot;Chinese Quote Serif&quot;, &quot;source serif pro&quot;, &quot;noto serif sc&quot;, &quot;source serif&quot;, &quot;source han serif sc&quot;, &quot;source han serif cn&quot;, serif;">这一段代码的功能可以算得上是非常简单了，然而它的长度达到了“令人发指”的</span> 10 行。当然，10 行长的函数不算什么。但是，在不阅读函数注释、不知道什么是 IPv6 ULA 的情况下，想理解这个函数，真正需要关心的代码只有 3 行：一行表明 IP 从何而来（首位 0xfd，六个随机 byte，以及一堆 0），一行表明 Mask 是什么（<code>/48</code>），以及函数的返回值处理（<code>String()</code>）。</p><p>目前，语法高亮不能在类似的代码阅读中提供任何帮助。它仅仅只是分析语法结构并以此着色。而语法在程序编写中是最不重要的一环，正如语法在文学创作中一样。</p><h3 id="语义分析的困难性与注解">语义分析的困难性，与注解</h3><p>好吧，这才是我想说的。</p><p>分析器也许并不可能自动做到我所说的功能，但我们完全可以通过其他扩展语法元素<em>通知</em>分析器这段代码是做什么的——我多希望有一种通用的、面向分析器的语法/协议。</p><p><span style="font-family: &quot;Chinese Quote Serif&quot;, &quot;source serif pro&quot;, &quot;noto serif sc&quot;, &quot;source serif&quot;, &quot;source han serif sc&quot;, &quot;source han serif cn&quot;, serif;">虽然我对在注释，或其类似物中填充“逻辑”深恶痛绝（没错，我说的就是 </span><code>// @ts-ignore</code>），但不得不承认这是一种最普适性的做法。</p><p>我称类似的元素为<strong>注解（Annotation）</strong>，注意此处并不特指 Java 里的那个注解，虽然其语义应当是类似的。</p><p>当今似乎并没有语法高亮器和静态分析工具提供普适性的类似功能，最符合我所说的还是 JetBrains 的 IntelliJ IDEA。IDEA 也是我发现的最早实现类似功能的 IDE。</p><p>IDEA 利用 Java 的 annotation 实现了类似的功能，其最为有用的部分是 <a href="https://www.jetbrains.com/help/idea/contract-annotations.html">Contract</a>，他〇的，全世界的 IDE 开发者都应该好好学学什么是真正面向用户需求的产品！</p><p>按上面链接官方文档所说，最简单的两个例子：</p><table><thead><tr><th>Contract</th><th>Effect</th></tr></thead><tbody><tr><td><code>@Contract("_, null -&gt; null")</code></td><td>The method returns <code>null</code> if its second argument is <code>null</code>.</td></tr><tr><td><code>@Contract("_, null -&gt; null; _, !null -&gt; !null")</code></td><td>The method returns <code>null</code> if its second argument is <code>null</code>, and not-null otherwise.</td></tr></tbody></table><p>当然这个功能是侵入式的，我个人觉得普适性不佳。在代码中平添了依赖。</p><p>类似的，JetBrains Rider 也有<a href="https://www.jetbrains.com/help/rider/Contract_Annotations.html">这样的功能</a>（NuGet JetBrains.Annotations）。不开玩笑的说，IDEA 和 Rider/ReSharper 领先所有其他 IDE 一个世代，JetBrains 简直就是世界的主宰！</p><p>当然这些功能都只是添头，并不能达到我所希望的美好愿景。因为这些已有的注解归根究底是辅助静态分析器的，貌似对语法高亮元素没有任何控制，不得不说这十分遗憾。</p><p>假如这些注解能够控制着色元素，例如，将某个函数的颜色标注为 <code>dimmed</code>，来将其的颜色变暗，其实就很能协助代码编写者突出查看核心代码了。但这也还不够，因为代码的大部分并不是函数调用，而是可恶的基本语句，以及大量的 if。对于基本语句的处理，我暂时还没有想到非常好的方法来控制。此外，对于外部库的控制，效果也会很差。</p><h2 id="结论">结论</h2><p><span style="font-family: &quot;Chinese Quote Serif&quot;, &quot;source serif pro&quot;, &quot;noto serif sc&quot;, &quot;source serif&quot;, &quot;source han serif sc&quot;, &quot;source han serif cn&quot;, serif;">总的来说，当今的“语法高亮”，确实依旧停留在“语法”上。白白浪费了字体、颜色等宝贵的信息量。大部分时候，这些高亮元素并不能给予程序员足够的提示。如果有一种方法，能够让程序编写者控制着色器，甚至自动折叠（</span>auto collapse code block）的工作，那么对提升代码阅读速度将有着质的提升，将开发者从海量的错误处理等代码中解放出来。</p><div id="refContainer"></div></article></div><div class="post-pager"><ul class="pager"><li class="previous"><a href="https://lingsamuel.github.io/page/2020-09-09-aur-dotnet-preview-upgrade-caution/">← AUR 更新 dotnet preview 时的注意事项</a></li><li class="next"><a href="https://lingsamuel.github.io/page/2020-09-22-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E8%B0%83%E8%AF%95%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1/">透明代理调试内网服务 →</a></li></ul></div></div></div><div id="toc"><aside><nav id="TableOfContents"><ul><li><a href="#当我们在谈论语法高亮时我们在谈论什么">当我们在谈论语法高亮时，我们在谈论什么</a><ul><li><a href="#忽略不关键的部分">忽略不关键的部分</a></li><li><a href="#无意义的高亮">无意义的高亮</a></li><li><a href="#语义分析的困难性与注解">语义分析的困难性，与注解</a></li></ul></li><li><a href="#结论">结论</a></li></ul></nav></aside></div></div><footer id="footer"><div class="footer"><p>Copyright © 2021
<a href="https://lingsamuel.github.io">Ling Samuel</a> • Powered by <a href="https://gohugo.io">Hugo v0.82.0</a> • Theme <a href="https://github.com/lingsamuel/purity">Purity</a> •
Hosted by GitHub</p></div></footer><link rel="stylesheet" href="https://lingsamuel.github.io/css/mermaid.min.css" media="screen" as="style" onload="this.rel='stylesheet'"></body></html>