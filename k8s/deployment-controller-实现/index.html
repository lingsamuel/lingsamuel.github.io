<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Deployment Controller 实现 - Hakurei Shrine</title><meta property="og:title" content="Deployment Controller 实现"><meta name=twitter:title content="Deployment Controller 实现"><meta name=author content="Ling Samuel"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Hakurei Shrine","url":"https:\/\/lingsamuel.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/lingsamuel.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/lingsamuel.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/lingsamuel.github.io\/k8s\/deployment-controller-%E5%AE%9E%E7%8E%B0\/","name":"Deployment controller 实现"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Ling Samuel"},"headline":"Deployment Controller 实现","description":"","inLanguage":"en","wordCount":4758,"datePublished":"2021-03-03T15:05:46","dateModified":"2021-03-03T15:05:46","image":"https:\/\/lingsamuel.github.io\/","keywords":[""],"mainEntityOfPage":"https:\/\/lingsamuel.github.io\/k8s\/deployment-controller-%E5%AE%9E%E7%8E%B0\/","publisher":{"@type":"Organization","name":"https:\/\/lingsamuel.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/lingsamuel.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Deployment Controller 实现"><meta property="og:url" content="https://lingsamuel.github.io/k8s/deployment-controller-%E5%AE%9E%E7%8E%B0/"><meta property="og:type" content="website"><meta property="og:site_name" content="Hakurei Shrine"><meta name=twitter:title content="Deployment Controller 实现"><meta name=twitter:card content="summary"><link href=https://lingsamuel.github.io/img/favicon.ico rel=icon type=image/x-icon><meta name=twitter:card content="summary"><meta property="og:url" content="https://lingsamuel.github.io/k8s/deployment-controller-%E5%AE%9E%E7%8E%B0/"><meta property="og:type" content="website"><meta property="og:site_name" content="Hakurei Shrine"><link rel=alternate href=https://lingsamuel.github.io/index.xml type=application/rss+xml title="Hakurei Shrine"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=preconnect href=https://fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100;300;400;500;700;900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://lingsamuel.github.io/css/highlight.min.css><link rel=stylesheet href=https://lingsamuel.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://lingsamuel.github.io/css/main.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-89095899-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body id=body><nav id=navbar class="navbar navbar-default navbar-fixed-top navbar-custom nav-bottom-border"><div class="container-fluid nav-container"><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://lingsamuel.github.io/>Hakurei Shrine</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Articles href=/page>Articles</a></li><li><a title=Reviews href=/review>Reviews</a></li><li><a title=Feeds href=/feed>Feeds</a></li><li><a title=About href=/about>About</a></li><li><a title=Categories href=/categories>Categories</a></li><li><a title=Tags href=/tags>Tags</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div id=intro-header class="intro-header no-img"><div class=container><div class=row><div class="col-lg-11 col-lg-offset-1"><div class=page-heading><h1>Deployment Controller 实现</h1><hr class=small><div class=post-meta style=display:flex;justify-content:space-between><span style=display:inline-flex>Posted on March 3, 2021
by Ling Samuel</span><div style=display:inline-flex;font-style:normal><span></span>&nbsp;
<a style=text-align:right href=deployment-controller/ onclick='return event.preventDefault(),function(a){navigator.clipboard.writeText(a.href),$(a).prev().text("url copied"),setTimeout(function(){$(a).prev().text("")},1e3)}(this)'>Copy Eternal Link</a></div></div><div class=blog-categories><a href=https://lingsamuel.github.io/categories/kubernetes/>kubernetes</a>&nbsp;</div></div></div></div></div></div></header><div class=container id=mainContainer role=main><div class=row><div class="col-lg-8 col-lg-offset-1"><article role=main class=blog-post><p>Deployment 通过控制 ReplicaSet，进而间接控制 Pod。</p><p>DeploymentController 主要的工作函数有二：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>DeploymentController</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// To allow injection of syncDeployment for testing.
</span><span class=c1></span>	<span class=nx>syncHandler</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dKey</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
	<span class=c1>// used for unit testing
</span><span class=c1></span>	<span class=nx>enqueueDeployment</span> <span class=kd>func</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>很常见的为了测试目的抽成的变量。</p><p>实际运行时 syncHandler 为 <code>syncDeployment</code>，是实际的 worker；enqueueDeployment 是 <code>enqueue</code>，作为 lister 回调里实际调用的函数，将更新信息不断入到 <code>queue</code> 中。</p><p><code>Run</code> 启动数个 worker goroutine，从 <code>queue</code> 中不断取出 key 并处理。</p><p>这是一段非常经典的 Controller 逻辑。</p><h2 id=实现原理>实现原理</h2><h3 id=informer>informer</h3><p>DeploymentController 除了监听 Deployment 本身的增改删然后触发同步 <code>syncDeployment</code> 以外，还会监听 ReplicaSet 的增删改与 Pod 的删除。</p><p>总体上，<code>addReplicaSet</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/deployment_controller.go#L199-L199>src</a>) 有三个工作要做：</p><ul><li>检查 DeletionTimestamp，确保（重启时）rs 被正确删除。逻辑移交给 <code>deleteReplicaSet</code>。</li><li>检查 rs 是否有 controller，如有且该 controller 是 Deployment，触发同步，且不再进入下一步。</li><li>只有孤儿 rs 能够进入这一步。检查是否有 deployment 可以收养（adopt）它。同步收养行为。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>addReplicaSet</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
	<span class=nx>rs</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>DeletionTimestamp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>deleteReplicaSet</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>controllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>rs</span><span class=p>);</span> <span class=nx>controllerRef</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>controllerRef</span><span class=p>)</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nx>ds</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getDeploymentsForReplicaSet</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ds</span> <span class=p>{</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>有关收养，可参考 <a href=/k8s/gc>Garbage Collector</a> 一文。</p><p>Deployment 对 ReplicaSet 的收养行为是检查是否有 deployment 的 selector 能 match 到该 rs 的 labels。如果有多个匹配的 deployment，取第一个并记录一条日志。</p><hr><p><code>updateReplicaSet</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/deployment_controller.go#L256-L256>src</a>):</p><ul><li>检查 controller 是否变动。如果变动了，那么也应该同步旧 controller（若存在）。</li><li>检查 rs 是否有 controller，如有且该 controller 是 Deployment，触发同步，且不再进入下一步。</li><li>只有孤儿 rs 能够进入这一步。如果 rs 的 label 或 controller 变动了，检查是否有 deployment 可以收养（adopt）它。同步收养行为。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>updateReplicaSet</span><span class=p>(</span><span class=nx>old</span><span class=p>,</span> <span class=nx>cur</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
	<span class=nx>curRS</span> <span class=o>:=</span> <span class=nx>cur</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=nx>oldRS</span> <span class=o>:=</span> <span class=nx>old</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>curRS</span><span class=p>.</span><span class=nx>ResourceVersion</span> <span class=o>==</span> <span class=nx>oldRS</span><span class=p>.</span><span class=nx>ResourceVersion</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nx>curControllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>curRS</span><span class=p>)</span>
	<span class=nx>oldControllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>oldRS</span><span class=p>)</span>
	<span class=nx>controllerRefChanged</span> <span class=o>:=</span> <span class=p>!</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>curControllerRef</span><span class=p>,</span> <span class=nx>oldControllerRef</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>controllerRefChanged</span> <span class=o>&amp;&amp;</span> <span class=nx>oldControllerRef</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>oldRS</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>oldControllerRef</span><span class=p>);</span> <span class=nx>d</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>curControllerRef</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>curRS</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>curControllerRef</span><span class=p>)</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nx>labelChanged</span> <span class=o>:=</span> <span class=p>!</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>curRS</span><span class=p>.</span><span class=nx>Labels</span><span class=p>,</span> <span class=nx>oldRS</span><span class=p>.</span><span class=nx>Labels</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>labelChanged</span> <span class=o>||</span> <span class=nx>controllerRefChanged</span> <span class=p>{</span>
		<span class=nx>ds</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getDeploymentsForReplicaSet</span><span class=p>(</span><span class=nx>curRS</span><span class=p>)</span>
		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ds</span> <span class=p>{</span>
			<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>这一块的逻辑很大程度上与 add 相同。</p><hr><p><code>deleteReplicaSet</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/deployment_controller.go#L304-L304>src</a>):</p><ul><li>检查 rs 是否有 controller，如有且该 controller 是 Deployment，触发同步。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>deleteReplicaSet</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
	<span class=nx>rs</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=nx>controllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>controllerRef</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// No controller should care about orphans being deleted.
</span><span class=c1></span>		<span class=k>return</span>
	<span class=p>}</span>
	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>controllerRef</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>
	<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>虽然我没列出来，但注意这块代码有一段对于 <code>DeletedFinalStateUnknown</code> 的处理。当删除发生时，如果到 API server 的连接断开了，那么删除事件就会丢失。</p><p>这是一个比较容易忘记的问题，例如 <code>NodeController</code> 曾经就有<a href=(https://github.com/kubernetes/kubernetes/issues/34692)>相关的 Bug</a>。</p><p><code>deletePod</code>:</p><ul><li>检查 Pod 的所有者是否是 rs，且该 rs 的所有者是否是 deployment。<ul><li>如果是，再检查该 deployment 的更新策略是否是 Recreate。</li><li>如果是，再检查该 deployment 的 pod 数是否是 0。</li><li>如果是，触发同步。</li></ul></li></ul><p>对于 Pod 删除的检查完全是为了 Recreate 服务。当更新策略为 recreate 的 deployment 下没有存活 Pod 时，可以触发 deployment 同步。</p><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>Note:</strong><p>注意，Deployment Controller 没有任何对 Pod 的直接操作。对 pod 副本数的保证是通过 ReplicaSet 完成的。Deployment Controller 可以认为是对 ReplicaSet 的一层封装。</p><p>虽然 Recreate 的实现监听了 Pod 的删除事件，但 Pod 的 scale down 是通过将 ReplicaSet 的 replicas 降至 0 完成的。</p></div><h3 id=syncdeployment>syncDeployment</h3><p><code>syncDeployment</code> 是 Deployment Controller 的核心同步逻辑。</p><ul><li>根据传进来的 key 获得 deployment 资源<ul><li>如果没有 selector，更新 Status 后直接返回。</li></ul></li><li>获取 rs 和 pods。</li><li>如果删除时间不为空，调用 <code>syncStatusOnly</code>，只同步 Status，然后结束。</li><li>检查暂停状态并更新 condition，避免错误的 timeout。如果是暂停状态，调用 <code>sync</code>，然后结束。</li><li>检查 rollback 状态，如果是，调用 <code>sync</code>，然后结束。</li><li>检查 scale 事件，如果是，调用 <code>sync</code>，然后结束。</li><li>检查更新策略：<ul><li>如果是 Recreate，调用 <code>rolloutRecreate</code>，会等待所有 pod 都被删除后再起新的副本。</li><li>如果是 RollingUpdate，则调用 <code>rolloutRolling</code>，将会根据 maxSurge 和 maxUnavailable 进行逐步更新。</li></ul></li></ul><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>Note:</strong><p>虽然 <code>sync</code> 的调用在前，但逻辑上它发生在 Rollout 之后，因此放在后面讲。</p></div><h3 id=rolloutrecreate>rolloutRecreate</h3><p>重建策略的逻辑较为简单 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/recreate.go#L28-L28>src</a>)。</p><ul><li>找到所有活跃的 rs，将它们全部 scale 至 0。<ul><li>注意此处的 <code>getAllReplicaSetsAndSyncRevision</code> 第三个参数为 false，表示不自动创建新 rs。</li></ul></li><li>如果依旧有旧 pod 在运行（scale 尚未结束），什么也不做。</li><li>如果没有新 rs，新建一个。<ul><li>将新建逻辑延迟到此，可避免在所有 rs 都被 scale 到 0 前就起了新的 pod。</li></ul></li><li>将新 rs scale 到需要的 replica。</li><li>如果 rollout 结束，调用 <code>cleanupDeployment</code> 清理所有旧的 replica。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// rolloutRecreate implements the logic for recreating a replica set.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>rolloutRecreate</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>podMap</span> <span class=kd>map</span><span class=p>[</span><span class=nx>types</span><span class=p>.</span><span class=nx>UID</span><span class=p>][]</span><span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>activeOldRSs</span> <span class=o>:=</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span>

	<span class=c1>// scale down old replica sets.
</span><span class=c1></span>	<span class=nx>scaledDown</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleDownOldReplicaSetsForRecreate</span><span class=p>(</span><span class=nx>activeOldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>scaledDown</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nf>oldPodsRunning</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>podMap</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>newRS</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
		<span class=nx>allRSs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleUpNewReplicaSetForRecreate</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>util</span><span class=p>.</span><span class=nf>DeploymentComplete</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>Status</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupDeployment</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=c1>// Sync deployment status.
</span><span class=c1></span>	<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h3 id=rolloutrolling>rolloutRolling</h3><p>滚动更新是更加复杂、更加常用的策略。</p><ul><li>获取所有 rs。</li><li>将新 rs scale up。如果成功 scale up 了，那么结束。</li><li>将旧 rs scale down。如果成功 scale down 了，那么结束。</li><li>如果 rollout 结束，调用 <code>cleanupDeployment</code> 清理所有旧的 replica。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// rolloutRolling implements the logic for rolling a new replica set.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>rolloutRolling</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>

	<span class=nx>scaledUp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>reconcileNewReplicaSet</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>scaledUp</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=c1>// Scale down, if we can.
</span><span class=c1></span>	<span class=nx>scaledDown</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>reconcileOldReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>),</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>scaledDown</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>DeploymentComplete</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>Status</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupDeployment</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>这个函数的逻辑看似简单清晰，但背后有着不少的设计。</p><p>为了保证滚动更新时的可用性，scale down 并不是与 scale up 同时发生的。可以看到如果能够 scale up 时，是不会进入 scale down 的逻辑的。</p><p>滚动更新的实质行为是根据 maxSurge 和 maxUnavailable 参数，反复“迭代”、交替进行，直到旧 rs scale down 至 0，新 rs scale up 至 Spec replica。</p><hr><p>如果仅仅是 scale down，那么自然可以一步到位（<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/rolling.go#L68-L68>src</a>）：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>reconcileNewReplicaSet</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>==</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>&gt;</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>scaled</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=nx>deployment</span><span class=p>)</span>
		<span class=k>return</span> <span class=nx>scaled</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>主要的问题在于 scale up 时，不能一步到位，而是需要根据 maxSurge 参数避免一次性起太多 pod，渐进式地提升新 rs 的 replica，直到符合 Spec：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>	<span class=nx>newReplicasCount</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>NewRSNewReplicas</span><span class=p>(</span><span class=nx>deployment</span><span class=p>,</span> <span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>scaled</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>newReplicasCount</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>)</span>
	<span class=k>return</span> <span class=nx>scaled</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></div><p>函数 <code>NewRSNewReplicas</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L816-L816>src</a>) 就是用来计算 replica 取何值的。</p><p>使用<code>期望数量 replica + 可容忍的额外数量 maxSurge</code>可以求出新旧 pod 共存的<code>最大数量 maxTotalPods</code>。如果当前的 pod 数量超过了，那么就返回 rs 的当前 replica 数，使得外层的 scale up 函数返回 false，进而走到 scale down 逻辑。</p><p>如果当前的 pod 数量不足时，使用<code>最大数量 maxTotalPods - 当前数量 currentPodCount</code>，可以得到本次迭代最多 scale up 的副本数。由于 maxSurge 可能非常大，还需要取这个结果与 Spec replica 中更小的一个。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>NewRSNewReplicas</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>switch</span> <span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Strategy</span><span class=p>.</span><span class=nx>Type</span> <span class=p>{</span>
	<span class=k>case</span> <span class=nx>apps</span><span class=p>.</span><span class=nx>RollingUpdateDeploymentStrategyType</span><span class=p>:</span>
		<span class=c1>// Check if we can scale up.
</span><span class=c1></span>		<span class=nx>maxSurge</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>intstrutil</span><span class=p>.</span><span class=nf>GetScaledValueFromIntOrPercent</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Strategy</span><span class=p>.</span><span class=nx>RollingUpdate</span><span class=p>.</span><span class=nx>MaxSurge</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)),</span> <span class=kc>true</span><span class=p>)</span>
		
		<span class=nx>currentPodCount</span> <span class=o>:=</span> <span class=nf>GetReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
		<span class=nx>maxTotalPods</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>+</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>maxSurge</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>currentPodCount</span> <span class=o>&gt;=</span> <span class=nx>maxTotalPods</span> <span class=p>{</span>
			<span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=kc>nil</span>
		<span class=p>}</span>
		<span class=nx>scaleUpCount</span> <span class=o>:=</span> <span class=nx>maxTotalPods</span> <span class=o>-</span> <span class=nx>currentPodCount</span>
		<span class=nx>scaleUpCount</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>integer</span><span class=p>.</span><span class=nf>IntMin</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>scaleUpCount</span><span class=p>),</span> <span class=nb>int</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span><span class=o>-*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>))))</span>
		<span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>+</span> <span class=nx>scaleUpCount</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><hr><p>在 scale down 时，也不能一次性将旧 replica scale 到 0。因此 <code>reconcileOldReplicaSets</code> 函数也需要根据 maxUnavailable 参数避免一次性移除太多 pod。</p><p>使用<code>期望数量 replica - 最小不可用数量 maxUnavailable</code>可求出至少需要有多少存活的 pod 数量 <code>minAvailable</code>。</p><p>此时注意，新 rs 不一定所有的 pod 都健康或 ready。我们实际使用的计算公式应该是 <code>可缩减数量 maxScaledDown = 当前可用数量 - 最小可用数量 minAvailable</code>。其中<code>当前可用数量 = 所有数量 allPodsCount - 新 rs 不可用数量 newRSUnavailablePodCount</code>。如果在新 rs 没有全部 ready 的情况下，仅考虑 maxUnavailable，简单地直接用会得到一个较大的 scale down 值，导致可用性不符合设计。</p><p>根据新 rs 的 <code>replica - availableReplicas</code> 可以求出新 rs 有多少 pod 不可用。根据上述公式即可求出本次迭代最多可以杀死几个 pod。如果小于等于零，说明可容忍的缩容程度已经到达限制了，应该将控制权移交回扩容，函数返回 false。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>reconcileOldReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>oldPodsCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>oldPodsCount</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>allPodsCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
	<span class=nx>maxUnavailable</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>MaxUnavailable</span><span class=p>(</span><span class=o>*</span><span class=nx>deployment</span><span class=p>)</span>
	<span class=nx>minAvailable</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>maxUnavailable</span>
	<span class=nx>newRSUnavailablePodCount</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>newRS</span><span class=p>.</span><span class=nx>Status</span><span class=p>.</span><span class=nx>AvailableReplicas</span>
	<span class=nx>maxScaledDown</span> <span class=o>:=</span> <span class=nx>allPodsCount</span> <span class=o>-</span> <span class=nx>minAvailable</span> <span class=o>-</span> <span class=nx>newRSUnavailablePodCount</span>
	<span class=k>if</span> <span class=nx>maxScaledDown</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>到目前为止，在计算可缩容数量时，并没有考虑到旧 rs 持有的 pod 可能不健康的情形。</p><p>为了保证可用性，我们必须保证实际可用的 pod 数量不少于 <code>minAvailable</code>。具体的可用性保证在 <code>scaleDownOldReplicaSetsForRollingUpdate</code> 函数 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/rolling.go#L192-L192>src</a>) 中：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>scaleDownOldReplicaSetsForRollingUpdate</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>maxUnavailable</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>MaxUnavailable</span><span class=p>(</span><span class=o>*</span><span class=nx>deployment</span><span class=p>)</span>
	<span class=nx>minAvailable</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>maxUnavailable</span>

	<span class=nx>availablePodCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetAvailableReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>availablePodCount</span> <span class=o>&lt;=</span> <span class=nx>minAvailable</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>当 available pod 数目不多于最小可用性要求时，scale down 不会发生。在很早期的版本中，这导致了潜在的问题。</p><p>优先考虑 scale down 不健康的 rs 有两个好处：</p><ol><li><p>（在当时的版本）rs 删除 pod 时会有如下优先级：<code>not-ready &lt; ready, unscheduled &lt; scheduled, and pending &lt; running</code>。这使得缩容不健康的 rs 并不会降低可靠性（因为它本身就不健康）。现在的 rs 删除 pod 考虑的更多，包括会尽量让 pod 分散在不同的节点上，等。</p></li><li><p>缩容健康的 rs 会导致可用数量检查不通过。如果现有的不健康 rs 始终无法恢复，那么缩容就停止了。</p></li></ol><p>因此需要首先调用 cleanupUnhealthyReplicas 清理不健康的 rs。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>reconcileOldReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>cleanupCount</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupUnhealthyReplicas</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>,</span> <span class=nx>maxScaledDown</span><span class=p>)</span>

	<span class=c1>// Scale down old replica sets, need check maxUnavailable to ensure we can scale down
</span><span class=c1></span>	<span class=nx>allRSs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>scaledDownCount</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleDownOldReplicaSetsForRollingUpdate</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>)</span>

	<span class=nx>totalScaledDown</span> <span class=o>:=</span> <span class=nx>cleanupCount</span> <span class=o>+</span> <span class=nx>scaledDownCount</span>
	<span class=k>return</span> <span class=nx>totalScaledDown</span> <span class=p>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>这两个缩容函数的行为模式与上述公式类似，不再赘述。区别在于，<code>cleanupUnhealthyReplicas</code> 会将不健康的 rs 缩容到 <code>replicas == availableReplicas</code>，而 <code>scaleDownOldReplicaSetsForRollingUpdate</code> 会直接尝试缩到尽可能小的值，比如 0。</p><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>Note:</strong><p><code>scaleDownOldReplicaSetsForRollingUpdate</code> 函数中有一个很奇怪的判断。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>scaleDownOldReplicaSetsForRollingUpdate</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>maxUnavailable</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>MaxUnavailable</span><span class=p>(</span><span class=o>*</span><span class=nx>deployment</span><span class=p>)</span>
	<span class=nx>minAvailable</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>maxUnavailable</span>
	<span class=nx>availablePodCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetAvailableReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>availablePodCount</span> <span class=o>&lt;=</span> <span class=nx>minAvailable</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>controller</span><span class=p>.</span><span class=nf>ReplicaSetsByCreationTimestamp</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>))</span>
	
	<span class=c1>// 已缩容的 replica
</span><span class=c1></span>	<span class=nx>totalScaledDown</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
	<span class=c1>// 最多缩容几个 replica。由于上面的可用性判断，totalScaleDownCount &gt; 0
</span><span class=c1></span>	<span class=nx>totalScaleDownCount</span> <span class=o>:=</span> <span class=nx>availablePodCount</span> <span class=o>-</span> <span class=nx>minAvailable</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>targetRS</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>oldRSs</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>totalScaledDown</span> <span class=o>&gt;=</span> <span class=nx>totalScaleDownCount</span> <span class=p>{</span>
			<span class=c1>// 缩容够了，退出
</span><span class=c1></span>			<span class=k>break</span>
		<span class=p>}</span>
		<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=k>continue</span>
		<span class=p>}</span>
		<span class=c1>// 缩容的数量。如果还能缩容的数量 (totalScaleDownCount - totalScaledDown) 比该 rs 的全部 replica 都多，那么直接缩到 0
</span><span class=c1></span>		<span class=nx>scaleDownCount</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>integer</span><span class=p>.</span><span class=nf>IntMin</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)),</span> <span class=nb>int</span><span class=p>(</span><span class=nx>totalScaleDownCount</span><span class=o>-</span><span class=nx>totalScaledDown</span><span class=p>)))</span>
		<span class=nx>newReplicasCount</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>scaleDownCount</span>
		<span class=c1>// 神秘的判断。如果 A = B - C 且 A &gt; B，那么说明 C 是负数。而 C = Min(B, totalScaleDownCount - totalScaledDown)
</span><span class=c1></span>		<span class=c1>// 但是由于 totalScaledDown &gt;= totalScaleDownCount 时直接退出了循环，所以此处的 totalScaleDownCount - totalScaledDown &gt; 0
</span><span class=c1></span>		<span class=c1>// 来源：https://github.com/kubernetes/kubernetes/pull/22828
</span><span class=c1></span>		<span class=c1>// 这个 PR 认为是 cleanup 时缩容了 rs，但是没有返回更新后的 oldRS。乍一看感觉好像很有道理，但问题是 cleanup 并不是异步的。
</span><span class=c1></span>		<span class=c1>// 假该 rs 在 cleanup 前有 3/5 个 replica，被 cleanup 缩容成了 3/3（这里一定会缩容到极限，而不会缩到比如 3/4。因为如果缩容名额不足了，那么就不会走到这个循环），然后修改后的值没有返回。
</span><span class=c1></span>		<span class=c1>// 因此这个函数里还是认为该 rs 是 3/5，那么，很显然这个计算逻辑依旧保证了 newReplicasCount 最小是 0，而不是负数。
</span><span class=c1></span>		<span class=c1>// 按理来说这个情形是不应该发生的。除非有别的地方并发地修改了 oldRSs 里的指针。但我好像没找到可疑的地方，不太懂。
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>newReplicasCount</span> <span class=p>&gt;</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;when scaling down old RS, got invalid request to scale down %s/%s %d -&gt; %d&#34;</span><span class=p>,</span> <span class=nx>targetRS</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>targetRS</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=nx>newReplicasCount</span><span class=p>)</span>
		<span class=p>}</span>
		<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>,</span> <span class=nx>newReplicasCount</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>totalScaledDown</span><span class=p>,</span> <span class=nx>err</span>
		<span class=p>}</span>

		<span class=nx>totalScaledDown</span> <span class=o>+=</span> <span class=nx>scaleDownCount</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>totalScaledDown</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div></div><h3 id=rollback>rollback</h3><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>TODO</strong></div><h3 id=pause>pause</h3><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>TODO</strong></div><h3 id=syncscale>sync/scale</h3><p>检查是否是 scale 事件的函数 <code>isScalingEvent</code> 比对 rs 和 deployment 的 replicas 字段不一致，则判定为一次扩缩容事件。</p><p><code>sync</code> 即是处理暂停或扩缩容事件的函数。</p><p>在同步时，会有“新 rs”与“旧 rs”的概念，通过 pod template hash 来区分 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L645-L645>src</a>)。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// FindNewReplicaSet returns the new RS this given deployment targets (the one with the same pod template).
</span><span class=c1></span><span class=kd>func</span> <span class=nf>FindNewReplicaSet</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span> <span class=p>{</span>
	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>controller</span><span class=p>.</span><span class=nf>ReplicaSetsByCreationTimestamp</span><span class=p>(</span><span class=nx>rsList</span><span class=p>))</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rsList</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nf>EqualIgnoreHash</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>rsList</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>rsList</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=c1>// new ReplicaSet does not exist.
</span><span class=c1></span>	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p><code>sync</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/sync.go#L298-L298>src</a>) 进行以下操作：</p><ul><li>更新 rs 的 revision number。</li><li>然后进行 scale。</li><li>如果发现 deployment 处于暂停状态，检查是否在进行 rollback。如果不是，那么会清理旧的 rs。</li><li>更新 Status。</li></ul><p>在 <code>scale</code> 函数中，如果 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L355-L355>src</a>)：</p><ul><li>没有活跃 rs（活跃 rs 指的是 replica 不为 0 的 rs）<ul><li>有“新 rs”，则返回新 rs</li><li>没有新 rs，则返回尽可能新的 rs</li></ul></li><li>有且恰好有一个活跃的 rs，则将其返回</li><li>有多于一个活跃的 fs，返回空。多于一个的活跃 rs 说明 deployment 正在滚动更新中，不应该直接操作。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>FindActiveOrLatest</span><span class=p>(</span><span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>newRS</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>sort</span><span class=p>.</span><span class=nf>Reverse</span><span class=p>(</span><span class=nx>controller</span><span class=p>.</span><span class=nf>ReplicaSetsByCreationTimestamp</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)))</span>
	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>))</span>

	<span class=k>switch</span> <span class=nb>len</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>case</span> <span class=mi>0</span><span class=p>:</span>
		<span class=k>if</span> <span class=nx>newRS</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>newRS</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=nx>oldRSs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>case</span> <span class=mi>1</span><span class=p>:</span>
		<span class=k>return</span> <span class=nx>allRSs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>default</span><span class=p>:</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>如果得到了一个活跃或尽可能新的 rs，那么直接对这个 rs 进行 scale：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>scale</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>activeOrLatest</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>FindActiveOrLatest</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>);</span> <span class=nx>activeOrLatest</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>activeOrLatest</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>==</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span>
		<span class=p>}</span>
		<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>activeOrLatest</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=nx>deployment</span><span class=p>)</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>如果发现新 rs 已经饱和（replica 达到期望状态）了，那么将旧 rs scale 成 0：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>	<span class=k>if</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>IsSaturated</span><span class=p>(</span><span class=nx>deployment</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>old</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>old</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>但是，如果 deployment 处于滚动更新中，有可能存在多个活跃的 rs，且均未饱和，应该继续滚动更新的逻辑。这一部分的详情，后文滚动更新一节会再次提到。</p><p>滚动更新需要给新 rs 起 pod，使新 rs 的 replica 接近 Spec；还需要降低旧 rs 的 replica，使之逐渐变为 0。</p><p>但是，我们不能一次性进行所有操作。为了降低风险，</p><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>TODO</strong></div><div class=highlight><pre class=chroma><code class=language-go data-lang=go>
	<span class=k>if</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>IsRollingUpdate</span><span class=p>(</span><span class=nx>deployment</span><span class=p>)</span> <span class=p>{</span>
</code></pre></div><div id=refContainer></div></article><ul class="pager blog-pager"></ul></div><aside id=toc class=col-lg-2><nav id=TableOfContents><ul><li><a href=#实现原理>实现原理</a><ul><li><a href=#informer>informer</a></li><li><a href=#syncdeployment>syncDeployment</a></li><li><a href=#rolloutrecreate>rolloutRecreate</a></li><li><a href=#rolloutrolling>rolloutRolling</a></li><li><a href=#rollback>rollback</a></li><li><a href=#pause>pause</a></li><li><a href=#syncscale>sync/scale</a></li></ul></li></ul></nav></aside></div></div><footer><div class=container><div class=row><div class="col-lg-10 col-lg-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:lingsamuelgrace@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/lingsamuel title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://lingsamuel.github.io/index.xml title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://lingsamuel.github.io>Ling Samuel</a>
&nbsp;&bull;&nbsp;&copy;
2021
&nbsp;&bull;&nbsp;
<a href=https://lingsamuel.github.io/>Hakurei Shrine</a></p><p class="credits theme-by text-muted"><a href=http://gohugo.io>Hugo v0.81.0</a> powered &nbsp;&bull;&nbsp; Theme by <a href=http://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a> adapted to <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> Modified by <a href=https://github.com/lingsamuel>LingSamuel</a></p></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://lingsamuel.github.io/js/main.js></script><script src=https://lingsamuel.github.io/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script>renderMathInElement(document.body)</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://lingsamuel.github.io/js/load-photoswipe.js></script></body></html>