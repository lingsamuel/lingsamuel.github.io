<!doctype html><html lang=zh itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Deployment Controller 实现 - Hakurei Shrine</title><meta property="og:title" content="Deployment Controller 实现"><meta name=twitter:title content="Deployment Controller 实现"><meta name=author content="Ling Samuel"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Hakurei Shrine","url":"https:\/\/lingsamuel.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/lingsamuel.github.io\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/lingsamuel.github.io\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/lingsamuel.github.io\/k8s\/controller\/deployment\/","name":"Deployment controller 实现"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Ling Samuel"},"headline":"Deployment Controller 实现","description":"","inLanguage":"en","wordCount":6505,"datePublished":"2021-03-03T15:05:46","dateModified":"2021-03-03T15:05:46","image":"https:\/\/lingsamuel.github.io\/","keywords":[""],"mainEntityOfPage":"https:\/\/lingsamuel.github.io\/k8s\/controller\/deployment\/","publisher":{"@type":"Organization","name":"https:\/\/lingsamuel.github.io\/","logo":{"@type":"ImageObject","url":"https:\/\/lingsamuel.github.io\/","height":60,"width":60}}}</script><meta property="og:title" content="Deployment Controller 实现"><meta property="og:url" content="https://lingsamuel.github.io/k8s/controller/deployment/"><meta property="og:type" content="website"><meta property="og:site_name" content="Hakurei Shrine"><meta name=twitter:title content="Deployment Controller 实现"><meta name=twitter:card content="summary"><link href=https://lingsamuel.github.io/img/favicon.ico rel=icon type=image/x-icon><meta name=twitter:card content="summary"><meta property="og:url" content="https://lingsamuel.github.io/k8s/controller/deployment/"><meta property="og:type" content="website"><meta property="og:site_name" content="Hakurei Shrine"><link rel=alternate href=https://lingsamuel.github.io/index.xml type=application/rss+xml title="Hakurei Shrine"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=preconnect href=https://fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100;300;400;500;700;900&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://lingsamuel.github.io/css/highlight.min.css><link rel=stylesheet href=https://lingsamuel.github.io/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><link rel=stylesheet href=https://lingsamuel.github.io/css/main.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-89095899-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body id=body><nav id=navbar class="navbar navbar-default navbar-fixed-top navbar-custom nav-bottom-border"><div class="container-fluid nav-container"><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button><div style=display:flex><a class=navbar-brand style=display:flex href=https://lingsamuel.github.io/><img src=https://lingsamuel.github.io/img/favicon.ico style=margin-right:5px;height:1em>Hakurei Shrine</a></div></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Articles href=/page>Articles</a></li><li><a title=Reviews href=/review>Reviews</a></li><li><a title=Feeds href=/feed>Feeds</a></li><li><a title=About href=/about>About</a></li><li><a title=Categories href=/categories>Categories</a></li><li><a title=Tags href=/tags>Tags</a></li></ul></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div id=intro-header class="intro-header no-img"><div class=container><div class=row><div class="col-lg-11 col-lg-offset-1"><div class=page-heading><h1>Deployment Controller 实现</h1><hr class=small><div class=post-meta style=display:flex;justify-content:space-between><span style=display:inline-flex>Posted on March 3, 2021
&nbsp;(Last modified on March 12, 2021)
by Ling Samuel</span><div style=display:inline-flex;font-style:normal><span></span>&nbsp;
<a style=text-align:right href=https://lingsamuel.github.io/k8s/deployment/ onclick='return event.preventDefault(),function(a){navigator.clipboard.writeText(a.href),$(a).prev().text("url copied"),setTimeout(function(){$(a).prev().text("")},1e3)}(this)'>Copy Eternal Link</a></div></div><div class=blog-categories><a href=https://lingsamuel.github.io/categories/kubernetes/>kubernetes</a>&nbsp;</div></div></div></div></div></div></header><div class=container id=mainContainer role=main><div class=row><div class="col-lg-8 col-lg-offset-1"><article role=main class=blog-post><p>Deployment 通过控制 ReplicaSet，进而间接控制 Pod。</p><p>DeploymentController 主要的工作函数有二：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>DeploymentController</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// To allow injection of syncDeployment for testing.
</span><span class=c1></span>	<span class=nx>syncHandler</span> <span class=kd>func</span><span class=p>(</span><span class=nx>dKey</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
	<span class=c1>// used for unit testing
</span><span class=c1></span>	<span class=nx>enqueueDeployment</span> <span class=kd>func</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>很常见的为了测试目的抽成的变量。</p><p>实际运行时 syncHandler 为 <code>syncDeployment</code>，是实际的 worker；enqueueDeployment 是 <code>enqueue</code>，作为 lister 回调里实际调用的函数，将更新信息不断入到工作队列 <code>queue</code> 中。</p><p><code>Run</code> 启动数个 worker goroutine，从工作队列 <code>queue</code> 中不断取出 key 并处理。</p><p>这是一段非常经典的 Controller 逻辑。</p><h2 id=实现原理>实现原理</h2><p>实线表示持有关系，虚线表示数据流向。</p><div class=mermaidTitle style=background:#eff1f3;color:#696874><strong align=center style="display:block;font-size:24px;font-family:noto sans">Deployment Controller</strong>
<span align=center style="display:block;font-size:12px;font-family:noto sans">Ling Samuel</span></div><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>graph TD
    DC(Deployment Controller)
		DI(Deployment Informer)
    RSI(ReplicaSet Informer)
    PI(Pod Informer)
    E(EventHandler)
		W(Workers)
    
		DC--&gt;DI
    DC--&gt;RSI
    DC--&gt;PI
    DC--&gt;W
    DC--&gt;Queue

    DI-. Deployment Event .-&gt;E
    PI-. Pod Event .-&gt;E
    RSI-. RS Event .-&gt;E

    E-. Enqueue Deployment .-&gt;Queue

    Queue-. Dequeue Deployment .-&gt;W

		class E Blue;
		class DI,RSI,PI,Queue Red;
		class DC Green;
    class W Yellow;
</code></pre></div><div class=mermaidTitle style=background:#eff1f3;color:#696874><strong align=center style="display:block;font-size:24px;font-family:noto sans">Deployment Structure</strong>
<span align=center style="display:block;font-size:12px;font-family:noto sans">Ling Samuel</span></div><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>graph TD
	D(Deployment)
	R1(ReplicaSet 1)
	R2(ReplicaSet 2)
	P1(Pod 1)
	P2(Pod 2)
	P3(Pod 1)
	P4(Pod 2)

	D--&gt;R1
	D--&gt;R2
	R1--&gt;P1
	R1--&gt;P2
	R2--&gt;P3
	R2--&gt;P4

	class D Green;
	class R1,R2 Red;
	class P1,P2,P3,P4 Yellow;
</code></pre></div><h3 id=informer>informer</h3><p>DeploymentController 除了监听 Deployment 本身的增改删然后触发同步 <code>syncDeployment</code> 以外，还会监听 ReplicaSet 的增删改与 Pod 的删除。</p><hr><p>总体上，<code>addReplicaSet</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/deployment_controller.go#L199-L199>src</a>) 有三个工作要做：</p><ul><li>检查 DeletionTimestamp，确保（重启时）rs 被正确删除。逻辑移交给 <code>deleteReplicaSet</code>。</li><li>检查 rs 是否有 controller，如有且该 controller 是 Deployment，入工作队列。</li><li>只有孤儿 rs 能够进入这一步。检查是否有 deployment 可以收养（adopt）它。若有，入工作队列。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>addReplicaSet</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
	<span class=nx>rs</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>DeletionTimestamp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>deleteReplicaSet</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>controllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>rs</span><span class=p>);</span> <span class=nx>controllerRef</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>controllerRef</span><span class=p>)</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nx>ds</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getDeploymentsForReplicaSet</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ds</span> <span class=p>{</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>有关收养，可参考 <a href=/k8s/gc>Garbage Collector</a> 一文。</p><p>Deployment 对 ReplicaSet 的收养行为是检查是否有 deployment 的 selector 能 match 到该 rs 的 labels。如果有多个匹配的 deployment，取第一个并记录一条日志。</p><hr><p><code>updateReplicaSet</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/deployment_controller.go#L256-L256>src</a>):</p><ul><li>检查新旧 rs 资源版本是否一致（由于 resync），如果一致则跳过。</li><li>检查 controller 是否变动。如果变动了，那么也应该同步旧 controller（若存在）。</li><li>检查 rs 的 controller 是否是 Deployment，将其入工作队列。</li><li>只有孤儿 rs 能够进入这一步。如果 rs 的 label 或 controller 变动了，检查是否有 deployment 可以收养（adopt）它。若有，入工作队列。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>updateReplicaSet</span><span class=p>(</span><span class=nx>old</span><span class=p>,</span> <span class=nx>cur</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
	<span class=nx>curRS</span> <span class=o>:=</span> <span class=nx>cur</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=nx>oldRS</span> <span class=o>:=</span> <span class=nx>old</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>curRS</span><span class=p>.</span><span class=nx>ResourceVersion</span> <span class=o>==</span> <span class=nx>oldRS</span><span class=p>.</span><span class=nx>ResourceVersion</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nx>curControllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>curRS</span><span class=p>)</span>
	<span class=nx>oldControllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>oldRS</span><span class=p>)</span>
	<span class=nx>controllerRefChanged</span> <span class=o>:=</span> <span class=p>!</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>curControllerRef</span><span class=p>,</span> <span class=nx>oldControllerRef</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>controllerRefChanged</span> <span class=o>&amp;&amp;</span> <span class=nx>oldControllerRef</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>oldRS</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>oldControllerRef</span><span class=p>);</span> <span class=nx>d</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>curControllerRef</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>curRS</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>curControllerRef</span><span class=p>)</span>
		<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=k>return</span>
	<span class=p>}</span>

	<span class=nx>labelChanged</span> <span class=o>:=</span> <span class=p>!</span><span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>curRS</span><span class=p>.</span><span class=nx>Labels</span><span class=p>,</span> <span class=nx>oldRS</span><span class=p>.</span><span class=nx>Labels</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>labelChanged</span> <span class=o>||</span> <span class=nx>controllerRefChanged</span> <span class=p>{</span>
		<span class=nx>ds</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getDeploymentsForReplicaSet</span><span class=p>(</span><span class=nx>curRS</span><span class=p>)</span>
		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>d</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ds</span> <span class=p>{</span>
			<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>这一块的逻辑很大程度上与 add 相同。</p><hr><p><code>deleteReplicaSet</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/deployment_controller.go#L304-L304>src</a>):</p><ul><li>检查 rs 是否有 controller，如有且该 controller 是 Deployment，入工作队列。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>deleteReplicaSet</span><span class=p>(</span><span class=nx>obj</span> <span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
	<span class=nx>rs</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>obj</span><span class=p>.(</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span>
	<span class=nx>controllerRef</span> <span class=o>:=</span> <span class=nx>metav1</span><span class=p>.</span><span class=nf>GetControllerOf</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>controllerRef</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// No controller should care about orphans being deleted.
</span><span class=c1></span>		<span class=k>return</span>
	<span class=p>}</span>
	<span class=nx>d</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>resolveControllerRef</span><span class=p>(</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>controllerRef</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>d</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>
	<span class=nx>dc</span><span class=p>.</span><span class=nf>enqueueDeployment</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>虽然我没列出来，但注意这块代码有一段对于 <code>DeletedFinalStateUnknown</code> 的处理。当删除发生时，如果到 API server 的连接断开了，那么删除事件就会丢失。</p><p>这是一个比较容易忘记的问题，例如 <code>NodeController</code> 曾经就有<a href=(https://github.com/kubernetes/kubernetes/issues/34692)>相关的 Bug</a>，ReplicaSet 也曾有过<a href=https://github.com/kubernetes/kubernetes/pull/82572>相关问题</a>。</p><hr><p><code>deletePod</code>:</p><ul><li>检查 Pod 的所有者是否是 rs，且该 rs 的所有者是否是 deployment。<ul><li>如果是，再检查该 deployment 的更新策略是否是 Recreate。</li><li>如果是，再检查该 deployment 的 pod 数是否是 0。</li><li>如果是，入工作队列。</li></ul></li></ul><p>对于 Pod 删除的检查完全是为了 Recreate 服务。当更新策略为 recreate 的 deployment 下没有存活 Pod 时，可以触发 deployment 同步。</p><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>Note:</strong><p>注意，Deployment Controller 没有任何对 Pod 的直接操作，理论上不应该监听 Pod 事件。对 pod 副本数的保证是通过 ReplicaSet 完成的。Deployment Controller 可以认为是对 ReplicaSet 的一层封装。</p><p>虽然 Recreate 的实现监听了 Pod 的删除事件，但 Pod 的 scale down 是通过将 ReplicaSet 的 replicas 降至 0 完成的。</p></div><h3 id=syncdeployment>syncDeployment</h3><p><code>syncDeployment</code> 是 Deployment Controller 的核心同步逻辑。</p><ul><li>根据传进来的 key 获得 deployment 资源。<ul><li>如果没有 selector，更新 Status 后直接返回。</li></ul></li><li>获取 rs 和 pods。</li><li>如果删除时间不为空，调用 <code>syncStatusOnly</code>，只同步 Status，然后结束。</li><li>检查暂停状态并更新 condition，避免错误的 timeout。如果是暂停状态，调用 <code>sync</code>，然后结束。</li><li>检查 rollback 状态，如果是，调用 <code>rollback</code>，然后结束。</li><li>检查 scale 事件，如果是，调用 <code>sync</code>，然后结束。</li><li>检查更新策略：<ul><li>如果是 Recreate，调用 <code>rolloutRecreate</code>，会等待所有 pod 都被删除后再创建新的副本。</li><li>如果是 RollingUpdate，则调用 <code>rolloutRolling</code>，将会根据 maxSurge 和 maxUnavailable 进行逐步更新。</li></ul></li></ul><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>Note:</strong><p>虽然 <code>sync</code> 的调用在前，但逻辑上它可能发生在 Rollout 之后，因此放在后面讲。</p></div><h3 id=rolloutrecreate>rolloutRecreate</h3><p>重建策略的逻辑较为简单 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/recreate.go#L28-L28>src</a>)。</p><ul><li>找到所有活跃的 rs，将它们全部 scale 至 0。<ul><li>注意此处的 <code>getAllReplicaSetsAndSyncRevision</code> 第三个参数为 false，表示不自动创建新 rs。</li></ul></li><li>如果依旧有旧 pod 在运行（scale 尚未结束），什么也不做。</li><li>如果没有新 rs，新建一个。<ul><li>将新建逻辑延迟到此，可避免在所有 rs 都被 scale 到 0 前就创建了新的 pod。</li></ul></li><li>将新 rs scale 到需要的 replica。</li><li>如果 rollout 结束，调用 <code>cleanupDeployment</code> 清理所有旧的 replica。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// rolloutRecreate implements the logic for recreating a replica set.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>rolloutRecreate</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>podMap</span> <span class=kd>map</span><span class=p>[</span><span class=nx>types</span><span class=p>.</span><span class=nx>UID</span><span class=p>][]</span><span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Pod</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>activeOldRSs</span> <span class=o>:=</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span>

	<span class=c1>// scale down old replica sets.
</span><span class=c1></span>	<span class=nx>scaledDown</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleDownOldReplicaSetsForRecreate</span><span class=p>(</span><span class=nx>activeOldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>scaledDown</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nf>oldPodsRunning</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>podMap</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>newRS</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
		<span class=nx>allRSs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleUpNewReplicaSetForRecreate</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>util</span><span class=p>.</span><span class=nf>DeploymentComplete</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>Status</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupDeployment</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=c1>// Sync deployment status.
</span><span class=c1></span>	<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><div><ul class="nav nav-tabs" role=tablist><li role=presentation class=active><a href=#Before aria-controls=Before role=tab data-toggle=tab>Before</a></li><li role=presentation><a href=#ScalingDown aria-controls=ScalingDown role=tab data-toggle=tab>ScalingDown</a></li><li role=presentation><a href=#After aria-controls=After role=tab data-toggle=tab>After</a></li></ul><div class=tab-content><div role=tabpanel class="tab-pane active" id=Before><div class=mermaidTitle style=background:#eff1f3;color:#696874><strong align=center style="display:block;font-size:24px;font-family:noto sans">Rollout Recreate: Before</strong>
<span align=center style="display:block;font-size:12px;font-family:noto sans">Ling Samuel</span></div><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>graph TD
		D(Deployment)
		R1(Active RS)
		R2(Old RS)
		P1(Active Pod 1)
		P2(Active Pod 2)
<pre><code>    D--&amp;gt;R1
	D--&amp;gt;R2
	R1--&amp;gt;P1
	R1--&amp;gt;P2

	class D Green;
	class R1,R2 Red;
	class P1,P2,P3,P4 Yellow;
</code></pre><p></code></pre></div></p></div><div role=tabpanel class=tab-pane id=ScalingDown><div class=mermaidTitle style=background:#eff1f3;color:#696874><strong align=center style="display:block;font-size:24px;font-family:noto sans">Rollout Recreate: Scale Down</strong>
<span align=center style="display:block;font-size:12px;font-family:noto sans">Ling Samuel</span></div><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>graph TD
		D(Deployment)
		R1(&#34;Active RS &lt;br/&gt;(ScaledDown)&#34;)
		R2(Old RS)
<pre><code>    D--&amp;gt;R1
	D--&amp;gt;R2

	class D Green;
	class R1,R2 Red;
	class P1,P2,P3,P4 Yellow;
</code></pre><p></code></pre></div></p></div><div role=tabpanel class=tab-pane id=After><div class=mermaidTitle style=background:#eff1f3;color:#696874><strong align=center style="display:block;font-size:24px;font-family:noto sans">Rollout Recreate: After</strong>
<span align=center style="display:block;font-size:12px;font-family:noto sans">Ling Samuel</span></div><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>graph TD
		D(Deployment)
		R1(New RS)
		R2(&#34;Old RS &lt;br/&gt;(Prev Active RS)&#34;)
		R3(Old RS)
		P1(Active Pod 1)
		P2(Active Pod 2)
<pre><code>    D--&amp;gt;R1
	D--&amp;gt;R2
	D--&amp;gt;R3
	R1--&amp;gt;P1
	R1--&amp;gt;P2

	class D Green;
	class R1,R2,R3 Red;
	class P1,P2,P3,P4 Yellow;
</code></pre><p></code></pre></div></p></div></div></div><h3 id=rolloutrolling>rolloutRolling</h3><p>滚动更新是更加复杂、更加常用的策略。</p><ul><li>获取所有 rs。</li><li>将新 rs scale up。如果成功 scale up 了，那么结束。</li><li>将旧 rs scale down。如果成功 scale down 了，那么结束。</li><li>如果 rollout 结束，调用 <code>cleanupDeployment</code> 清理所有旧的 replica。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// rolloutRolling implements the logic for rolling a new replica set.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>rolloutRolling</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>

	<span class=nx>scaledUp</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>reconcileNewReplicaSet</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>scaledUp</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=c1>// Scale down, if we can.
</span><span class=c1></span>	<span class=nx>scaledDown</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>reconcileOldReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>),</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>scaledDown</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>DeploymentComplete</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>Status</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupDeployment</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncRolloutStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>这个函数的逻辑看似简单清晰，但背后有着不少的设计。</p><p>为了保证滚动更新时的可用性，scale down 并不是与 scale up 同时发生的。可以看到如果能够 scale up 时，是不会进入 scale down 的逻辑的。</p><p>滚动更新的实质行为是根据 maxSurge 和 maxUnavailable 参数，反复“迭代”、交替进行，直到旧 rs scale down 至 0，新 rs scale up 至 Spec replica。</p><hr><p>如果仅仅是 scale down，那么自然可以一步到位（<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/rolling.go#L68-L68>src</a>）：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>reconcileNewReplicaSet</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>==</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>&gt;</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>scaled</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=nx>deployment</span><span class=p>)</span>
		<span class=k>return</span> <span class=nx>scaled</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>主要的问题在于 scale up 时，不能一步到位，而是需要根据 maxSurge 参数避免一次性创建太多 pod，渐进式地提升新 rs 的 replica，直到符合 Spec：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>	<span class=nx>newReplicasCount</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>NewRSNewReplicas</span><span class=p>(</span><span class=nx>deployment</span><span class=p>,</span> <span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>scaled</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>newReplicasCount</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>)</span>
	<span class=k>return</span> <span class=nx>scaled</span><span class=p>,</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></div><p>函数 <code>NewRSNewReplicas</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L816-L816>src</a>) 就是用来计算 replica 取何值的。</p><p>使用<code>期望数量 replica + 可容忍的额外数量 maxSurge</code>可以求出新旧 pod 共存的<code>最大数量 maxTotalPods</code>。如果当前的 pod 数量超过了，那么就返回 rs 的当前 replica 数，使得外层的 scale up 函数返回 false，进而走到 scale down 逻辑。</p><p>如果当前的 pod 数量不足时，使用<code>最大数量 maxTotalPods - 当前数量 currentPodCount</code>，可以得到本次迭代最多 scale up 的副本数。由于 maxSurge 可能非常大，还需要取这个结果与 Spec replica 中更小的一个。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>NewRSNewReplicas</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>switch</span> <span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Strategy</span><span class=p>.</span><span class=nx>Type</span> <span class=p>{</span>
	<span class=k>case</span> <span class=nx>apps</span><span class=p>.</span><span class=nx>RollingUpdateDeploymentStrategyType</span><span class=p>:</span>
		<span class=c1>// Check if we can scale up.
</span><span class=c1></span>		<span class=nx>maxSurge</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>intstrutil</span><span class=p>.</span><span class=nf>GetScaledValueFromIntOrPercent</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Strategy</span><span class=p>.</span><span class=nx>RollingUpdate</span><span class=p>.</span><span class=nx>MaxSurge</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)),</span> <span class=kc>true</span><span class=p>)</span>
		
		<span class=nx>currentPodCount</span> <span class=o>:=</span> <span class=nf>GetReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
		<span class=nx>maxTotalPods</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>+</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>maxSurge</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>currentPodCount</span> <span class=o>&gt;=</span> <span class=nx>maxTotalPods</span> <span class=p>{</span>
			<span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=kc>nil</span>
		<span class=p>}</span>
		<span class=nx>scaleUpCount</span> <span class=o>:=</span> <span class=nx>maxTotalPods</span> <span class=o>-</span> <span class=nx>currentPodCount</span>
		<span class=nx>scaleUpCount</span> <span class=p>=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>integer</span><span class=p>.</span><span class=nf>IntMin</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=nx>scaleUpCount</span><span class=p>),</span> <span class=nb>int</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span><span class=o>-*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>))))</span>
		<span class=k>return</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>+</span> <span class=nx>scaleUpCount</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><hr><p>在 scale down 时，也不能一次性将旧 replica scale 到 0。因此 <code>reconcileOldReplicaSets</code> 函数也需要根据 maxUnavailable 参数避免一次性移除太多 pod。</p><p>使用<code>期望数量 replica - 最小不可用数量 maxUnavailable</code>可求出至少需要有多少存活的 pod 数量 <code>minAvailable</code>。</p><p>此时注意，新 rs 不一定所有的 pod 都健康或 ready。我们实际使用的计算公式应该是 <code>可缩减数量 maxScaledDown = 当前可用数量 - 最小可用数量 minAvailable</code>。其中<code>当前可用数量 = 所有数量 allPodsCount - 新 rs 不可用数量 newRSUnavailablePodCount</code>。如果在新 rs 没有全部 ready 的情况下，仅考虑 maxUnavailable，简单地直接用会得到一个较大的 scale down 值，导致可用性不符合设计。</p><p>根据新 rs 的 <code>replica - availableReplicas</code> 可以求出新 rs 有多少 pod 不可用。根据上述公式即可求出本次迭代最多可以杀死几个 pod。如果小于等于零，说明可容忍的缩容程度已经到达限制了，应该将控制权移交回扩容，函数返回 false。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>reconcileOldReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>oldPodsCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>oldPodsCount</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>allPodsCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
	<span class=nx>maxUnavailable</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>MaxUnavailable</span><span class=p>(</span><span class=o>*</span><span class=nx>deployment</span><span class=p>)</span>
	<span class=nx>minAvailable</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>maxUnavailable</span>
	<span class=nx>newRSUnavailablePodCount</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>newRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>newRS</span><span class=p>.</span><span class=nx>Status</span><span class=p>.</span><span class=nx>AvailableReplicas</span>
	<span class=nx>maxScaledDown</span> <span class=o>:=</span> <span class=nx>allPodsCount</span> <span class=o>-</span> <span class=nx>minAvailable</span> <span class=o>-</span> <span class=nx>newRSUnavailablePodCount</span>
	<span class=k>if</span> <span class=nx>maxScaledDown</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>false</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>到目前为止，在计算可缩容数量时，并没有考虑到旧 rs 持有的 pod 可能不健康的情形。</p><p>为了保证可用性，我们必须保证实际可用的 pod 数量不少于 <code>minAvailable</code>。具体的可用性保证在 <code>scaleDownOldReplicaSetsForRollingUpdate</code> 函数 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/rolling.go#L192-L192>src</a>) 中：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>scaleDownOldReplicaSetsForRollingUpdate</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>maxUnavailable</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>MaxUnavailable</span><span class=p>(</span><span class=o>*</span><span class=nx>deployment</span><span class=p>)</span>
	<span class=nx>minAvailable</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>maxUnavailable</span>

	<span class=nx>availablePodCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetAvailableReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>availablePodCount</span> <span class=o>&lt;=</span> <span class=nx>minAvailable</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>当 available pod 数目不多于最小可用性要求时，scale down 不会发生。在很早期的版本中，这导致了潜在的问题。</p><p>优先考虑 scale down 不健康的 rs 有两个好处：</p><ol><li><p>（在当时的版本）rs 删除 pod 时会有如下优先级：<code>not-ready &lt; ready, unscheduled &lt; scheduled, and pending &lt; running</code>。这使得缩容不健康的 rs 并不会降低可靠性（因为它本身就不健康）。现在的 rs 删除 pod 考虑的更多，包括会尽量让 pod 分散在不同的节点上，等。</p></li><li><p>缩容健康的 rs 会导致可用数量检查不通过。如果现有的不健康 rs 始终无法恢复，那么缩容就停止了。</p></li></ol><p>因此需要首先调用 cleanupUnhealthyReplicas 清理不健康的 rs。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>reconcileOldReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>cleanupCount</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupUnhealthyReplicas</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>,</span> <span class=nx>maxScaledDown</span><span class=p>)</span>

	<span class=c1>// Scale down old replica sets, need check maxUnavailable to ensure we can scale down
</span><span class=c1></span>	<span class=nx>allRSs</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>scaledDownCount</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleDownOldReplicaSetsForRollingUpdate</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>)</span>

	<span class=nx>totalScaledDown</span> <span class=o>:=</span> <span class=nx>cleanupCount</span> <span class=o>+</span> <span class=nx>scaledDownCount</span>
	<span class=k>return</span> <span class=nx>totalScaledDown</span> <span class=p>&gt;</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>这两个缩容函数的行为模式与上述公式类似，不再赘述。区别在于，<code>cleanupUnhealthyReplicas</code> 会将不健康的 rs 缩容到 <code>replicas == availableReplicas</code>，而 <code>scaleDownOldReplicaSetsForRollingUpdate</code> 会直接尝试缩到尽可能小的值，比如 0。</p><div class="alert alert-info"><svg class="svg-inline fa-w-11" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></svg><strong>Note:</strong><p><code>scaleDownOldReplicaSetsForRollingUpdate</code> 函数中有一个很奇怪的判断。</p><details><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>scaleDownOldReplicaSetsForRollingUpdate</span><span class=p>(</span><span class=nx>allRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=p>(</span><span class=kt>int32</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>maxUnavailable</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>MaxUnavailable</span><span class=p>(</span><span class=o>*</span><span class=nx>deployment</span><span class=p>)</span>
	<span class=nx>minAvailable</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>maxUnavailable</span>
	<span class=nx>availablePodCount</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>GetAvailableReplicaCountForReplicaSets</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>availablePodCount</span> <span class=o>&lt;=</span> <span class=nx>minAvailable</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>controller</span><span class=p>.</span><span class=nf>ReplicaSetsByCreationTimestamp</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>))</span>
	
	<span class=c1>// 已缩容的 replica
</span><span class=c1></span>	<span class=nx>totalScaledDown</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
	<span class=c1>// 最多缩容几个 replica。由于上面的可用性判断，totalScaleDownCount &gt; 0
</span><span class=c1></span>	<span class=nx>totalScaleDownCount</span> <span class=o>:=</span> <span class=nx>availablePodCount</span> <span class=o>-</span> <span class=nx>minAvailable</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>targetRS</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>oldRSs</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>totalScaledDown</span> <span class=o>&gt;=</span> <span class=nx>totalScaleDownCount</span> <span class=p>{</span>
			<span class=c1>// 缩容够了，退出
</span><span class=c1></span>			<span class=k>break</span>
		<span class=p>}</span>
		<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=k>continue</span>
		<span class=p>}</span>
		<span class=c1>// 缩容的数量。如果还能缩容的数量 (totalScaleDownCount - totalScaledDown) 比该 rs 的全部 replica 都多，那么直接缩到 0
</span><span class=c1></span>		<span class=nx>scaleDownCount</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>integer</span><span class=p>.</span><span class=nf>IntMin</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)),</span> <span class=nb>int</span><span class=p>(</span><span class=nx>totalScaleDownCount</span><span class=o>-</span><span class=nx>totalScaledDown</span><span class=p>)))</span>
		<span class=nx>newReplicasCount</span> <span class=o>:=</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>-</span> <span class=nx>scaleDownCount</span>
		<span class=c1>// 神秘的判断。如果 A = B - C 且 A &gt; B，那么说明 C 是负数。而 C = Min(B, totalScaleDownCount - totalScaledDown)
</span><span class=c1></span>		<span class=c1>// 但是由于 totalScaledDown &gt;= totalScaleDownCount 时直接退出了循环，所以此处的 totalScaleDownCount - totalScaledDown &gt; 0
</span><span class=c1></span>		<span class=c1>// 来源：https://github.com/kubernetes/kubernetes/pull/22828
</span><span class=c1></span>		<span class=c1>// 这个 PR 认为是 cleanup 时缩容了 rs，但是没有返回更新后的 oldRS。乍一看感觉好像很有道理，但问题是 cleanup 并不是异步的。
</span><span class=c1></span>		<span class=c1>// 假该 rs 在 cleanup 前有 3/5 个 replica，被 cleanup 缩容成了 3/3（这里一定会缩容到极限，而不会缩到比如 3/4。因为如果缩容名额不足了，那么就不会走到这个循环），然后修改后的值没有返回。
</span><span class=c1></span>		<span class=c1>// 因此这个函数里还是认为该 rs 是 3/5，那么，很显然这个计算逻辑依旧保证了 newReplicasCount 最小是 0，而不是负数。
</span><span class=c1></span>		<span class=c1>// 按理来说这个情形是不应该发生的。除非有别的地方并发地修改了 oldRSs 里的指针。但我好像没找到可疑的地方，不太懂。
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>newReplicasCount</span> <span class=p>&gt;</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;when scaling down old RS, got invalid request to scale down %s/%s %d -&gt; %d&#34;</span><span class=p>,</span> <span class=nx>targetRS</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>,</span> <span class=nx>targetRS</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=nx>newReplicasCount</span><span class=p>)</span>
		<span class=p>}</span>
		<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>targetRS</span><span class=p>,</span> <span class=nx>newReplicasCount</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>totalScaledDown</span><span class=p>,</span> <span class=nx>err</span>
		<span class=p>}</span>

		<span class=nx>totalScaledDown</span> <span class=o>+=</span> <span class=nx>scaleDownCount</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>totalScaledDown</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div></details></div><h3 id=rollback>rollback</h3><p>每个 Deployment 都有 Revision 概念。保留的最大 Revision 数由 Spec 中的 <code>RevisionHistoryLimit</code> 决定。</p><p>前文可以发现，Deployment 对 rs 的操作一般是 scale 到 0，而不是直接删除。这是因为 Deployment 的历史版本是通过保留一个 Replicas 为 0、有着旧版 PodTemplate 的 rs 来实现的。对于 rs 的删除逻辑，在 <code>cleanupDeployment</code> 中处理。</p><p>前文已经数次提到 <code>cleanupDeployment</code> 这个函数 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/sync.go#L435-L435>src</a>)，它的作用就是清理超过保留数的 ReplicaSet。</p><ul><li>若 <code>RevisionHistoryLimit == math.MaxInt32</code>，代表保留所有副本，于是什么也不做。</li><li>排除没有 DeletionTimestamp 的存活 rs。</li><li>按 Revision 排序。如果没有 Revision 或 Revision 相同，按 CreationTimestamp 排序。Revision 储存在注解 <code>deployment.kubernetes.io/revision</code> 中。</li><li>删除超出 RevisionHistoryLimit 的 rs。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>cleanupDeployment</span><span class=p>(</span><span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=k>if</span> <span class=p>!</span><span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>HasRevisionHistoryLimit</span><span class=p>(</span><span class=nx>deployment</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>aliveFilter</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>rs</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>rs</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>ObjectMeta</span><span class=p>.</span><span class=nx>DeletionTimestamp</span> <span class=o>==</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=nx>cleanableRSes</span> <span class=o>:=</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>aliveFilter</span><span class=p>)</span>

	<span class=nx>diff</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>cleanableRSes</span><span class=p>))</span> <span class=o>-</span> <span class=o>*</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>RevisionHistoryLimit</span>
	<span class=k>if</span> <span class=nx>diff</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>ReplicaSetsByRevision</span><span class=p>(</span><span class=nx>cleanableRSes</span><span class=p>))</span>

	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>diff</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>rs</span> <span class=o>:=</span> <span class=nx>cleanableRSes</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
		<span class=c1>// Avoid delete replica set with non-zero replica counts
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>Status</span><span class=p>.</span><span class=nx>Replicas</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=o>*</span><span class=p>(</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>||</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>Generation</span> <span class=p>&gt;</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>Status</span><span class=p>.</span><span class=nx>ObservedGeneration</span> <span class=o>||</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>DeletionTimestamp</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>continue</span>
		<span class=p>}</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>AppsV1</span><span class=p>().</span><span class=nf>ReplicaSets</span><span class=p>(</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>).</span><span class=nf>Delete</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>TODO</span><span class=p>(),</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>DeleteOptions</span><span class=p>{});</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>errors</span><span class=p>.</span><span class=nf>IsNotFound</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>回滚是在 Kubectl 中调用的 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/staging/src/k8s.io/kubectl/pkg/polymorphichelpers/rollback.go#L99-L99>src</a>)。Deployment Controller 收到 Rollback 请求后 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/rollback.go#L34-L34>src</a>)：</p><ul><li>若 <code>ToRevision == 0</code>，从现存 rs 中寻找次新的 Revision。如果没有找到，放弃这次 Rollback。</li><li>寻找现存 rs 中匹配 ToRevision 的 rs。如果找到，那么复制该 rs 的 PodTemplate 到 deployment 上，并将非 metadata 的注解复制到 deployment 上。<ul><li>metadata 注解包括 Revision、RevisionHistory 等，<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L294-L294>详见此</a>。</li></ul></li><li>没有找到，放弃这次 Rollback。</li></ul><p>无论是找到了还是没有找到，都会通过调用 <code>updateDeploymentAndClearRollbackTo</code> 发起一次 Update 请求。回滚操作分了两步，第一步更新注解，服务端会解析这个注解，然后再发起真正的回滚请求（依旧是一次更新操作）。当然，即使没有找到对应的 revision，也会发送一次更新请求删掉这个 Rollback 注解。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>rollback</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>newRS</span><span class=p>,</span> <span class=nx>allOldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>allOldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=nx>rollbackTo</span> <span class=o>:=</span> <span class=nf>getRollbackTo</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>rollbackTo</span><span class=p>.</span><span class=nx>Revision</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>rollbackTo</span><span class=p>.</span><span class=nx>Revision</span> <span class=p>=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>LastRevision</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>);</span> <span class=nx>rollbackTo</span><span class=p>.</span><span class=nx>Revision</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>updateDeploymentAndClearRollbackTo</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>rs</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>allRSs</span> <span class=p>{</span>
		<span class=nx>v</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>Revision</span><span class=p>(</span><span class=nx>rs</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>rollbackTo</span><span class=p>.</span><span class=nx>Revision</span> <span class=p>{</span>
			<span class=nx>performedRollback</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>rollbackToTemplate</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rs</span><span class=p>)</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>updateDeploymentAndClearRollbackTo</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>rollbackToTemplate</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rs</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=p>(</span><span class=kt>bool</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>performedRollback</span> <span class=o>:=</span> <span class=kc>false</span>
	<span class=k>if</span> <span class=p>!</span><span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>EqualIgnoreHash</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>d</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>rs</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>)</span> <span class=p>{</span>
		<span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>SetFromReplicaSetTemplate</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rs</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>)</span>
		<span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>SetDeploymentAnnotationsTo</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rs</span><span class=p>)</span>
		<span class=nx>performedRollback</span> <span class=p>=</span> <span class=kc>true</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>performedRollback</span><span class=p>,</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>updateDeploymentAndClearRollbackTo</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>而 <code>updateDeploymentAndClearRollbackTo</code> 函数则清除了 rollback 注解，避免注解残留 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/rollback.go#L115-L115>src</a>)：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>updateDeploymentAndClearRollbackTo</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nf>setRollbackTo</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=kc>nil</span><span class=p>)</span>
	<span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nx>client</span><span class=p>.</span><span class=nf>AppsV1</span><span class=p>().</span><span class=nf>Deployments</span><span class=p>(</span><span class=nx>d</span><span class=p>.</span><span class=nx>Namespace</span><span class=p>).</span><span class=nf>Update</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>TODO</span><span class=p>(),</span> <span class=nx>d</span><span class=p>,</span> <span class=nx>metav1</span><span class=p>.</span><span class=nx>UpdateOptions</span><span class=p>{})</span>
	<span class=k>return</span> <span class=nx>err</span>
<span class=p>}</span>
</code></pre></div><p>我们从 <code>FindNewReplicaSet</code> 的实现中可以发现，更新时会优先复用已有的、同 PodTemplate 的 rs。而在回滚这个功能上，是必定能够找到已有的 rs 的。因此回滚时会重新 scale up 已存在的 rs，而非重新创建一个 rs。</p><h3 id=pauseresume>pause/resume</h3><p>暂停和恢复功能，主要是用于临时停止滚动更新，用到的场景不是很多。</p><p>暂停的 Deployment 不响应任何操作，以便于我们修复损坏的 Deployment。</p><p>和 Rollback 一样，pause/resume 也是在 Kubectl 端实现的 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/staging/src/k8s.io/kubectl/pkg/polymorphichelpers/objectpauser.go#L32-L32>src</a>)，原理是更新 <code>Spec.Paused</code> 的值。Resume 同理。</p><p>暂停 Deployment 的具体实现与 Scaling 一致，因此一同放在 <code>sync</code> 一节中讲述。</p><h3 id=sync>sync</h3><p>在 <code>syncDeployment</code> 中，检查是否是 scale 事件的函数 <code>isScalingEvent</code> 比对活跃 rs 和 deployment 的 replicas 字段，若不一致则判定为一次扩缩容事件。</p><p><code>sync</code> 即是处理暂停或扩缩容事件的函数。注意，这并不是一个常规的 Rollout 流程。常规的 Rollout 流程在上面进行，不应该走到这里。</p><p>在同步时，会有“新 rs”与“旧 rs”的概念，通过 pod template hash 来区分 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L645-L645>src</a>)。</p><p>“新 rs”指的是 PodTemplate 与目标 PodTemplate 一致的 rs，它会尽量复用已存在的 rs。</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>FindNewReplicaSet</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span> <span class=p>{</span>
	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>controller</span><span class=p>.</span><span class=nf>ReplicaSetsByCreationTimestamp</span><span class=p>(</span><span class=nx>rsList</span><span class=p>))</span>
	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>rsList</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nf>EqualIgnoreHash</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>rsList</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Template</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>rsList</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
		<span class=p>}</span>
	<span class=p>}</span>
	<span class=c1>// new ReplicaSet does not exist.
</span><span class=c1></span>	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p><code>sync</code> (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/sync.go#L298-L298>src</a>) 进行以下操作：</p><ul><li>更新 rs 的 revision number，如果存在新 rs，找到它。</li><li>进行 scale。</li><li>如果发现 deployment 处于暂停状态，检查是否在进行 rollback。如果不是，那么会清理旧的 rs。</li><li>更新 Status。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>sync</span><span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>rsList</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>getAllReplicaSetsAndSyncRevision</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>rsList</span><span class=p>,</span> <span class=kc>false</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scale</span><span class=p>(</span><span class=nx>d</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>d</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Paused</span> <span class=o>&amp;&amp;</span> <span class=nf>getRollbackTo</span><span class=p>(</span><span class=nx>d</span><span class=p>)</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>cleanupDeployment</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>d</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>err</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span>
	<span class=k>return</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>syncDeploymentStatus</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>,</span> <span class=nx>d</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>在 <code>scale</code> 函数中，首先通过 <code>FindActiveOrLatest</code> 函数，尝试是否能获得单个 rs 进行直接操作（有且只有一个活跃 rs，或者全部 rs 都不活跃）。如果 (<a href=https://github.com/kubernetes/kubernetes/blob/16b909ce1483258464715c9ab76b4dff82d596e5/pkg/controller/deployment/util/deployment_util.go#L355-L355>src</a>)：</p><ul><li>没有活跃 rs（活跃 rs 指的是 replica 不为 0 的 rs）。<ul><li>有“新 rs”，则返回新 rs（Active）。</li><li>返回旧 rs 中尽可能新的 rs（Latest）。</li></ul></li><li>有且恰好有一个活跃的 rs，则将其返回（Active）。</li><li>有多于一个活跃的 fs，返回空。多于一个的活跃 rs 说明 deployment 正在滚动更新中，不应该直接操作。</li></ul><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>FindActiveOrLatest</span><span class=p>(</span><span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>newRS</span> <span class=o>==</span> <span class=kc>nil</span> <span class=o>&amp;&amp;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>

	<span class=nx>sort</span><span class=p>.</span><span class=nf>Sort</span><span class=p>(</span><span class=nx>sort</span><span class=p>.</span><span class=nf>Reverse</span><span class=p>(</span><span class=nx>controller</span><span class=p>.</span><span class=nf>ReplicaSetsByCreationTimestamp</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)))</span>
	<span class=nx>allRSs</span> <span class=o>:=</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>))</span>

	<span class=k>switch</span> <span class=nb>len</span><span class=p>(</span><span class=nx>allRSs</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>case</span> <span class=mi>0</span><span class=p>:</span>
		<span class=k>if</span> <span class=nx>newRS</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>newRS</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=nx>oldRSs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>case</span> <span class=mi>1</span><span class=p>:</span>
		<span class=k>return</span> <span class=nx>allRSs</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
	<span class=k>default</span><span class=p>:</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>如果得到了一个活跃或尽可能新的 rs，那么直接对这个 rs 进行 scale：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>dc</span> <span class=o>*</span><span class=nx>DeploymentController</span><span class=p>)</span> <span class=nf>scale</span><span class=p>(</span><span class=nx>deployment</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>Deployment</span><span class=p>,</span> <span class=nx>newRS</span> <span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>,</span> <span class=nx>oldRSs</span> <span class=p>[]</span><span class=o>*</span><span class=nx>apps</span><span class=p>.</span><span class=nx>ReplicaSet</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nx>activeOrLatest</span> <span class=o>:=</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>FindActiveOrLatest</span><span class=p>(</span><span class=nx>newRS</span><span class=p>,</span> <span class=nx>oldRSs</span><span class=p>);</span> <span class=nx>activeOrLatest</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>if</span> <span class=o>*</span><span class=p>(</span><span class=nx>activeOrLatest</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=o>==</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>return</span> <span class=kc>nil</span>
		<span class=p>}</span>
		<span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>activeOrLatest</span><span class=p>,</span> <span class=o>*</span><span class=p>(</span><span class=nx>deployment</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>Replicas</span><span class=p>),</span> <span class=nx>deployment</span><span class=p>)</span>
		<span class=k>return</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>如果发现新 rs 已经饱和（replica 达到期望状态）了，那么将旧 rs scale 成 0：</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go>	<span class=k>if</span> <span class=nx>deploymentutil</span><span class=p>.</span><span class=nf>IsSaturated</span><span class=p>(</span><span class=nx>deployment</span><span class=p>,</span> <span class=nx>newRS</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>old</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>controller</span><span class=p>.</span><span class=nf>FilterActiveReplicaSets</span><span class=p>(</span><span class=nx>oldRSs</span><span class=p>)</span> <span class=p>{</span>
			<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>dc</span><span class=p>.</span><span class=nf>scaleReplicaSetAndRecordEvent</span><span class=p>(</span><span class=nx>old</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>deployment</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
				<span class=k>return</span> <span class=nx>err</span>
			<span class=p>}</span>
		<span class=p>}</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span></code></pre></div><p>但是，如果 deployment 处于滚动更新中，有可能存在多个活跃的 rs，且均未饱和，滚动更新的逻辑依旧在继续。</p><p>滚动更新时发生的扩缩容事件，应该均等地分布在所有的 rs 上。当前的实现，是从新到旧扩容，从旧到新缩容。</p><p>这一部分的扩缩容应该按比例进行。公式为：<code>可扩容的额外副本数 / 当前副本数</code>。展开来即：<code>(Spec.Replicas + MaxSurge - Status.Replicas) / Status.Replicas</code>，这个比例最后将乘上 rs 的 Spec.Replicas，再经过一些转换（最小值取 1、不超过期望值等）便可得到每个 rs 的 replicas 变化。</p><p>得到更新后的 rs 列表后，再调用 Update 函数将更新提交至服务器，一次扩缩容便完成了。</p><h2 id=总结>总结</h2><p>Deployment Controller 的实现从概念上讲，还是比较简单、清晰的。</p><p>但是，概念简单离实现正确之间往往相距非常遥远。Deployment Controller 的实现考虑了很多比较细节和边界的情况（例如 revision number、generation、hash collision 等），本文并没有仔细阐述。</p><p>如果要实现自己的控制器，参考 Deployment Controller 的实现，或直接复用 Deployment，会是比较好的选择。</p><div id=refContainer></div></article><ul class="pager blog-pager"><li class=next><a href=https://lingsamuel.github.io/k8s/controller/pod-gc/ data-toggle=tooltip data-placement=top title="Pod GC Controller">Next Post &rarr;</a></li></ul></div><aside id=toc class=col-lg-2><nav id=TableOfContents><ul><li><a href=#实现原理>实现原理</a><ul><li><a href=#informer>informer</a></li><li><a href=#syncdeployment>syncDeployment</a></li><li><a href=#rolloutrecreate>rolloutRecreate</a></li><li><a href=#rolloutrolling>rolloutRolling</a></li><li><a href=#rollback>rollback</a></li><li><a href=#pauseresume>pause/resume</a></li><li><a href=#sync>sync</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></aside></div></div><footer><div class=container><div class=row><div class="col-lg-10 col-lg-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:lingsamuelgrace@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/lingsamuel title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://lingsamuel.github.io/index.xml title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i><i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://lingsamuel.github.io>Ling Samuel</a>
&nbsp;&bull;&nbsp;&copy;
2021
&nbsp;&bull;&nbsp;
<a href=https://lingsamuel.github.io/>Hakurei Shrine</a></p><p class="credits theme-by text-muted"><a href=http://gohugo.io>Hugo v0.81.0</a> powered &nbsp;&bull;&nbsp; Theme by <a href=http://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a> adapted to <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> Modified by <a href=https://github.com/lingsamuel/beautifulhugo>LingSamuel</a></p></div></div></div></footer><script data-stage=prerender src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script data-stage=prerender src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous></script><script src=https://code.jquery.com/jquery-3.5.1.slim.min.js integrity=sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj crossorigin=anonymous></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script src=https://lingsamuel.github.io/js/main.js></script><script data-stage=prerender>$(document).ready(updateHeaderLang)</script><link href=https://lingsamuel.github.io/css/mermaid.css type=text/css rel=stylesheet><script data-stage=prerender src=https://lingsamuel.github.io/js/mermaid.min.js></script><script data-stage=prerender src=https://lingsamuel.github.io/js/highlight.min.js></script><script data-stage=prerender>hljs.initHighlightingOnLoad();const mermaidKeywords=["graph TD","graph TB","graph BT","graph RL","graph LR","sequenceDiagram","gantt","classDiagram","gitGraph","erDiagram","journey"];function colorizeMermaid(a){const b=`
    linkStyle default fill:none,stroke:grey;
    classDef default stroke:#97999a,color:#696874;
    classDef def stroke:#97999a,color:#696874;
    classDef Blue stroke:#97999a,fill:#76aac2,color:#eff1f3;
    classDef Grey stroke:#97999a,fill:#696773,color:#eef0f2;
    classDef Red stroke:#97999a,fill:#f19b97,color:#fcefee;
    classDef Green stroke:#97999a,fill:#79d8ce,color:#edf0f2;
    classDef Yellow stroke:#97999a,fill:#fcd766,color:#807971;`;return a.startsWith("graph")?a+b:a}var elements=$(".language-fallback").each((d,b)=>{var c=b.innerText,a;mermaidKeywords.some(a=>c.startsWith(a))&&(a=b.parentElement.parentElement,a.className=="highlight"&&(a.className="mermaid",a.innerHTML=colorizeMermaid(c),a.align="center",a.style="background: #eff1f3;"))})</script><script data-stage=prerender>mermaid.initialize({startOnLoad:!1}),mermaid.mermaidAPI.initialize();function cyrb53(c,d=0){let a=3735928559^d,b=1103547991^d;for(let d=0,e;d<c.length;d++)e=c.charCodeAt(d),a=Math.imul(a^e,2654435761),b=Math.imul(b^e,1597334677);return a=Math.imul(a^a>>>16,2246822507)^Math.imul(b^b>>>13,3266489909),b=Math.imul(b^b>>>16,2246822507)^Math.imul(a^a>>>13,3266489909),4294967296*(2097151&b)+(a>>>0)}let existed={};function calculateHash(b){let a=cyrb53(b);return typeof existed[a]=="number"&&(a=existed[a]+1),existed[a]=a,a}document.querySelectorAll('.mermaid').forEach(function(b){let a=b.textContent;console.log("Rendering ",a);let c="graph-"+calculateHash(a);mermaid.mermaidAPI.render(c,a,a=>{b.innerHTML=a})})</script><script data-stage=prerender>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script data-stage=prerender>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://lingsamuel.github.io/js/load-photoswipe.js></script></body></html>